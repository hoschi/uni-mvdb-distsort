<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html dir="ltr">
  <head>
	  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	  <link rel="stylesheet" type="text/css" href="http://ajax.googleapis.com/ajax/libs/dojo/1.5/dijit/themes/claro/claro.css"
	  />
	  <style type="text/css">
		body, html 
		{
		  height:100%;
		  width:100%;
		}
	  </style>
	  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/dojo/1.5/dojo/dojo.xd.js"
			  djConfig="parseOnLoad: true, dojoCallbackUrl:'./blank.html'">
	  </script>
	  <script type="text/javascript">
		/* required modules for the basic chart */
		//Main 2d chart class
		dojo.require("dojox.charting.Chart2D");
		dojo.require("dojox.charting.action2d.Magnify");
		dojo.require("dojox.charting.action2d.Tooltip");
		//Class to create a legend for our chart
		dojo.require("dojox.charting.widget.Legend");
		//A theme for our chart
		dojo.require("dojox.charting.themes.PlotKit.green");
		createPlot = function(node) {
			var node = new dojox.charting.Chart2D(node);
			//add the default plot
			node.addPlot("default", {
					//type of chart
					type: "Lines",
					//show markers at number points?
					markers: true,
					//curve the lines on the plot?
					tension: "S",
					//show lines?
					lines: true,
					//fill in areas?
					areas: false,
					//offset position for label
					labelOffset: -30,
			});
			node.addAxis("x", {
			  natural: true,
			  // our logarithmic labels
			  labels: [
				{value: 1, text: "1 * 10^3"},
				{value: 2, text: "5 * 10^3"},
				{value: 3, text: "7 * 10^3"},
				{value: 4, text: "1 * 10^3"},
				{value: 5, text: "3 * 10^4"},
				{value: 6, text: "5 * 10^4"},
				{value: 7, text: "7 * 10^4"},
				{value: 8, text: "1 * 10^5"},
			  ]
			});
			node.addAxis("y", { vertical:true });
			var magnify = new dojox.charting.action2d.Magnify(node, "default");
			var tip = new dojox.charting.action2d.Tooltip(node, "default");
			return node;
		};
		renderPlot = function(node,data) {
			var node = createPlot(node);
			node.addSeries("merge sort",data["merge"], { stroke: "green"});
			node.addSeries("distribution sort",data["dist"], { stroke: "blue"});
			node.render();
		};

		dojo.ready(function() {
			var local = {
				local: [19, 25, 6, 15, 23, 38, 63, 96],
				};
			var node = createPlot("chart1");
			node.addSeries("local sort",local["local"], { stroke: "red"});
			node.render();

			var run1 = {
				merge: [122, 330, 159, 93, 292, 692, 1337, 2644],
				dist: [120, 189, 161, 79, 267, 776, 1876, 4195]
				};
			renderPlot("chart2", run1);
			var run2 = {
				merge: [93, 328, 335, 122, 498, 1261, 2321, 4748],
				dist: [169, 363, 131, 61, 797, 1367, 4240, 6579]
				};
			renderPlot("chart3", run2);
			var run3 = {
				merge: [102, 463, 157, 128, 482, 1253, 2384, 4655],
				dist: [121, 271, 156, 98, 499, 2037, 3388, 4715]
				};
			renderPlot("chart4", run3);
			var run4 = {
				merge: [132, 403, 199, 168, 559, 1377, 2554, 5009],
				dist: [172, 225, 131, 151, 694, 1433, 2665, 8981]
				};
			renderPlot("chart5", run4);
		});

	  </script>
  </head>

  
  <body class="claro">
    <h1>Sortierung</h1>
	<p>
		Getestet wurde das Programm auf einem Quad Core mit 2600MHz pro Core
		und 8GB Arbeitsspeicher. Betriebssystem ist Debian Lenny amd64 mit
		modifiziertem XEN Kernel. Zeitliche Messungen sind in der JVM
		schwierig, durch die verwendete HotSpot Technologie. Das sieht man auch
		hier deutlich am "Knick" im ersten Diagramm. Eigentlich sollte die
		Kurve mehr oder weniger linear ansteigen.
	</p>
	<p>
		Das lokale Sortieren ist wesentlich schneller, unabhängig von der
		Datengröße die zu sortieren ist. Das liegt massiv daran, das durch RMI
		ein Overhead entsteht:
		<ul>
			<li>es müssen Listen umkopiert werden da keine Referenzen
			übertragen werden</li>
			<li>de-/seriealisieren der Daten</li>
			<li>TCP/IP zur Kommunikation</li>
		</ul>
		Das sortieren wird auch langsamer, umso kleiner die Blockgröße gewählt
		wird. Durch mehr Blöcke ensteht mehr Kommunikationsaufwand.
	</p>
	<p>
		Das der verteilte Distribution Sort Algorithmus ist, mit zunehmender
		Daten Größe, langsamer als der verteilte Merge Sort Algorithmus. Das
		liegt meiner Meinung daran das beim Distribution Sort ein zusäztlicher
		Lesezyklus vorhanden ist um die Grenzelemente auszulosen, sowie die
		Verwendung von Zufallszahlen. Ersteres macht sich natürlich bei großen
		Datenmengen stärker bemerkbar.
	</p>
	<p>
	todo
	- einheiten für axen
	- tabelle mit daten adden unter jedes diagramm
	</p>

	<h2>lokale Sortierung</h2>
		Wenn man mit der Maus über den Datenpunkt fährt, sieht man direkt den Wert.
	<div id="chart1"></div>
	<h2>Blockgröße = unendlich</h2>
		Legende:
		<ul>
			<li>grün = merge sort</li>
			<li>blau = distribution sort</li>
		</ul>
	<div id="chart2"></div>
	<h2>Blockgröße = 10000</h2>
	<div id="chart3"></div>
	<h2>Blockgröße = 1000</h2>
	<div id="chart4"></div>
	<h2>Blockgröße = 100</h2>
	<div id="chart5"></div>
  </body>
</html>
